/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package javaWebserver;

import akka.Done;
import akka.NotUsed;
import akka.actor.typed.ActorRef;
import akka.actor.typed.ActorSystem;
import akka.actor.typed.javadsl.Behaviors;
import akka.http.javadsl.Http;
import akka.http.javadsl.common.EntityStreamingSupport;
import akka.http.javadsl.common.JsonEntityStreamingSupport;
import akka.http.javadsl.marshallers.jackson.Jackson;
import akka.http.javadsl.model.StatusCodes;
import akka.http.javadsl.model.ws.Message;
import akka.http.javadsl.model.ws.TextMessage;
import akka.http.javadsl.server.AllDirectives;
import akka.http.javadsl.server.Route;
import akka.japi.JavaPartialFunction;
import akka.japi.Pair;
import akka.stream.OverflowStrategy;
import akka.stream.javadsl.Flow;
import akka.stream.javadsl.Sink;
import akka.stream.javadsl.Source;
import akka.stream.typed.javadsl.ActorSource;
import akka.util.ByteString;

import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.CompletionStage;

import com.fasterxml.jackson.annotation.*;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.ObjectMapper;

public class App extends AllDirectives {
  private final ActorSystem<Void> system;
  private static final ObjectMapper defaultObjectMapper = new ObjectMapper().enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);

  public String getGreeting() {
    return "Hello World!";
  }

  public App(ActorSystem<Void> system ) {
    this.system = system;
  }

  public static void main(String[] args) {
    ActorSystem<Void> system = ActorSystem.create(Behaviors.setup(context -> {
      context.spawn(TcpApp.create(), "tcp-app");

      return Behaviors.empty();
    }), "root");

    App app = new App(system);

    Http
        .get(system)
        .newServerAt("0.0.0.0", 3000)
        .bind(app.createRoute());
  }

  private Route createRoute() {
    var compactJsonSupport = createJsonStreamer();

    return concat(
      pathPrefix(
        "api",
        () -> concat(
          path(
            "json",
            () -> get(
                () -> complete(StatusCodes.OK, JsonObj.random(), Jackson.<JsonObj>marshaller())
            )
          )
        )
      ),
      path(
        "ws",
        () -> handleWebSocketMessages(stream())
      ),
      path(
        "stream",
          () -> get(() -> parameter("times", times -> {
            Integer num_times = Integer.parseInt(times);

            Source<JsonObj, NotUsed> source = Source.range(0, num_times).map(x -> JsonObj.random());

            return completeOKWithSource(
              source
                .log("streamer"),
              Jackson.marshaller(),
              compactJsonSupport
            );
          })
        )
      )
    );
  }

  public Flow<Message, Message, NotUsed> stream() {
    Source<JsonNode, ActorRef<JsonNode>> messageStream = ActorSource.<JsonNode>actorRef(
      m -> false,
      m -> Optional.empty(),
      1_024_000,
      OverflowStrategy.dropTail()
    );

    Pair<ActorRef<JsonNode>, Source<JsonNode, NotUsed>> pair = messageStream.preMaterialize(system);

    Sink<Message, CompletionStage<Done>> sink = Sink.foreach(item -> {
      TextMessage msg = item.asTextMessage();

      if (msg.isStrict()) {
        Integer num_times = Integer.parseInt(msg.getStrictText());
        System.out.println("Send "+ num_times + " messages");

        for (int i = 0; i < num_times; i++) {
          // pair.first().tell(defaultObjectMapper.valueToTree(JsonObj.random()));
          pair.first().tell(defaultObjectMapper.createObjectNode().put("name", UUID.randomUUID().toString()));
        }
      } else {
        System.out.println("Non strict WS messages not supported");
      }
    });

    Flow<Message, Message, NotUsed> flow = Flow
      .fromSinkAndSource(sink, pair.second())
      .map(msg -> TextMessage.create(defaultObjectMapper.writeValueAsString(msg)));

    return flow;
  }

  /**
   * Create a JSON streamer
   * Prepends data with "[", separates messages with "," and ends with "]"
   */
  private JsonEntityStreamingSupport createJsonStreamer() {
    final ByteString start = ByteString.fromString("[");
    final ByteString between = ByteString.fromString(",");
    final ByteString end = ByteString.fromString("]");
    final Flow<ByteString, ByteString, NotUsed> compactArrayRendering = Flow
      .of(ByteString.class)
      .intersperse(start, between, end);
    return EntityStreamingSupport.json().withFramingRendererFlow(compactArrayRendering);
  }

  @JsonFormat
  public static class JsonObj {
    @JsonProperty("name")
    public String name;

    public JsonObj(String name) {
      this.name = name;
    }

    public static JsonObj random() {
      return new JsonObj(UUID.randomUUID().toString());
    }
  }
}
